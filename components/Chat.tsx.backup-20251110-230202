/**
 * Chat UI component for MVP chat portal
 *
 * ‚ö†Ô∏è CRITICAL WARNING - DO NOT MODIFY THE SIDEBAR IMPLEMENTATION ‚ö†Ô∏è
 * This component MUST use AppSidebar from './layout/AppSidebar'
 * DO NOT create custom sidebars or replace AppSidebar unless explicitly requested
 * The sidebar provides:
 *   - Page navigation (Chat, Models, Secrets, Training, Analytics)
 *   - User settings dropdown with logout
 *   - Conversations list passed as children
 *
 * Last broken: Oct 20, 2025 - someone replaced AppSidebar with custom sidebar
 * Last fixed: Oct 21, 2025 - restored AppSidebar integration
 */
"use client";

import React, { useState, useEffect, useCallback, useRef, useMemo } from "react";
import { Button } from "./ui/button";
import { Input } from "./ui/input";
import { useAuth } from "../contexts/AuthContext";
import { logSessionEvent } from "../lib/sessionLogs";
import { supabase } from "../lib/supabaseClient";
import { getEnabledTools } from "../lib/tools/toolManager";
import { AppSidebar } from "./layout/AppSidebar";
import { useDocuments } from "../hooks/useDocuments";
import { useArchive } from "../hooks/useArchive";
import { DocumentUpload } from "./graphrag/DocumentUpload";
import { DocumentList } from "./graphrag/DocumentList";
import { ArchiveManager } from "./export/ArchiveManager";
import { ResearchStreamViewer } from "./research/ResearchStreamViewer";
import { ExportDialog } from "./export/ExportDialog";
import {
  Archive,
  Database,
  Download,
  MoreVertical,
  CheckSquare,
  Trash2,
  Search,
  MessageSquare,
  StopCircle,
  Mic,
  MicOff,
  Settings,
  Send,
  Plus,
  RefreshCw
} from "lucide-react";
import type { Citation } from "@/lib/graphrag/service";
import { EvaluationModal } from "./evaluation/EvaluationModal";
import { ModelSelector } from "./models/ModelSelector";
import { MessageList } from "./chat/MessageList";
import { ChatCommandPalette } from "./chat/ChatCommandPalette";
import { ChatHeader } from "./chat/ChatHeader";
import { ContextInspectorPanel } from "./debug/ContextInspectorPanel";
import { ModelComparisonView } from "./evaluation/ModelComparisonView";
import { ContextTracker } from "@/lib/context/context-tracker";
import type { ConversationModelContextRecord } from "@/lib/context/types";
import { ContextIndicator } from "./chat/ContextIndicator";
import type { ContextUsage } from "@/lib/context/types";
import { useTextToSpeech, type SpeechOptions } from "@/hooks/useTextToSpeech";
import { useSpeechRecognition } from "@/hooks/useSpeechRecognition";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "./ui/dropdown-menu";
import { SettingsDialog } from "./settings/SettingsDialog";
import type { UserSettings } from "@/lib/settings/types";
import { log } from "@/lib/utils/logger";
import { useConversationValidation } from "@/hooks/useConversationValidation";
import type { Message, SidebarConversation, ChatProps, OpenModal } from "./chat/types";

export default function Chat({ widgetConfig }: ChatProps) {
  // Render counter for debugging
  const renderCount = useRef(0);
  renderCount.current++;
  
  const { user, session, signOut } = useAuth();
  const userId = user?.id || null;
  
  // Track what changed to cause renders (moved to effect to avoid render-loop risks)
  const prevPropsRef = useRef<{ widgetConfig?: ChatProps['widgetConfig']; userId?: string | null }>({});
  useEffect(() => {
    const widgetChanged = prevPropsRef.current.widgetConfig !== widgetConfig;
    const userChanged = prevPropsRef.current.userId !== userId;
    if (widgetChanged || userChanged) {
      log.trace('Chat', 'Props changed', {
        renderCount: renderCount.current,
        widgetChanged,
        userChanged
      });
      prevPropsRef.current = { widgetConfig, userId };
    }

    // Commit-phase render trace
    log.trace('Chat', 'Committed render', { renderCount: renderCount.current });
  });

  const [conversations, setConversations] = useState<SidebarConversation[]>([]);
  const [activeId, setActiveId] = useState<string>("");
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);
  const [messages, setMessages] = useState<Message[]>([]);
  const [feedback, setFeedback] = useState<{ [key: string]: number }>({});
  const [connectionError, setConnectionError] = useState<boolean>(false);
  const [copiedMessageId, setCopiedMessageId] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [debugInfo, setDebugInfo] = useState<string>("");
  const [tools, setTools] = useState<
    Array<{
      type: string;
      function: { name: string; description: string; parameters: unknown };
    }>
  >([]);
  
  // Modal state management - consolidated using imported OpenModal type
  const [openModal, setOpenModal] = useState<OpenModal>(null);
  
  const [openMenuId, setOpenMenuId] = useState<string | null>(null);
  const [archivingId, setArchivingId] = useState<string | null>(null);
  const [evaluatingMessageId, setEvaluatingMessageId] = useState<string | null>(null);
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedModelId, setSelectedModelId] = useState<string>("__default__");
  const [selectedModel, setSelectedModel] = useState<{ id: string; name: string; context_length: number } | null>(null);
  const [availableModels, setAvailableModels] = useState<Array<{ id: string; name: string }>>([]);
  const [researchProgress, setResearchProgress] = useState<{
    jobId: string;
    status: string;
    currentStep: string;
    totalSteps: number;
    completedSteps: number;
  } | null>(null);
  // State for structured research (v2 with SSE streaming)
  const [activeResearchJob, setActiveResearchJob] = useState<{
    jobId: string;
    query: string;
  } | null>(null);
  const [abortController, setAbortController] = useState<AbortController | null>(null);
  const [searchExpanded, setSearchExpanded] = useState(false);

  // Web search options
  const [enableDeepResearch, setEnableDeepResearch] = useState(false);
  const [selectMode, setSelectMode] = useState(false);
  const [selectedConvIds, setSelectedConvIds] = useState<Set<string>>(new Set());

  // Context tracking state
  const [contextUsage, setContextUsage] = useState<ContextUsage | null>(null);
  const contextTrackerRef = useRef<ContextTracker | null>(null);

  // TTS state management
  const [selectedVoiceURI, setSelectedVoiceURI] = useState<string | undefined>();
  const [autoSpeakEnabled, setAutoSpeakEnabled] = useState(false);
  const [speakingMessageId, setSpeakingMessageId] = useState<string | null>(null);

  const {
    isSpeaking,
    isPaused,
    speak,
    cancel,
    pause,
    resume,
    isSupported: ttsSupported
  } = useTextToSpeech({
    onEnd: () => {
      log.debug('Chat', 'TTS ended');
      setSpeakingMessageId(null);
    },
    onStart: () => log.debug('Chat', 'TTS started'),
    onError: (error) => log.error('Chat', 'TTS error', { error })
  });

  // Settings state
  const [userSettings, setUserSettings] = useState<UserSettings | null>(null);

  // Session tagging state (for A/B testing and model comparison analytics)
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [experimentName, setExperimentName] = useState<string | null>(null);

  // Memoize speech recognition callbacks to prevent infinite re-renders
  const handleSpeechResult = useCallback((text: string, isFinal: boolean) => {
    if (isFinal) {
      log.debug('Chat', 'Final transcript', { text });
      // Add the final transcript to the input
      setInput(prev => (prev + ' ' + text).trim());
    } else {
      log.trace('Chat', 'Interim transcript', { text });
    }
  }, []);

  const handleSpeechStart = useCallback(() => {
    log.debug('Chat', 'STT started');
    // Stop TTS when starting to speak
    if (isSpeaking) {
      log.debug('Chat', 'Stopping TTS to avoid interference');
      cancel();
    }
  }, [isSpeaking, cancel]);

  const handleSpeechEnd = useCallback(() => {
    log.debug('Chat', 'STT ended');
  }, []);

  const handleSpeechError = useCallback((error: string) => {
    log.error('Chat', 'STT error', { error });
  }, []);

  // Memoize speech recognition options object
  const speechRecognitionOptions = useMemo(() => ({
    onResult: handleSpeechResult,
    onStart: handleSpeechStart,
    onEnd: handleSpeechEnd,
    onError: handleSpeechError
  }), [handleSpeechResult, handleSpeechStart, handleSpeechEnd, handleSpeechError]);

  // Speech recognition for voice-to-text
  const {
    isListening,
    startListening,
    stopListening,
    isSupported: sttSupported,
    error: sttError
  } = useSpeechRecognition(speechRecognitionOptions);

  // Session tagging handlers
  const handleSessionChange = useCallback((newSessionId: string, newExperimentName: string) => {
    log.info('Chat', 'Session tagged', { sessionId: newSessionId, experimentName: newExperimentName });
    setSessionId(newSessionId);
    setExperimentName(newExperimentName);

    // Log session event for analytics
    if (activeId) {
      logSessionEvent('session_tagged', {
        conversationId: activeId,
        sessionId: newSessionId,
        experimentName: newExperimentName,
      });
    }
  }, [activeId]);

  const handleClearSession = useCallback(() => {
    log.info('Chat', 'Session cleared');
    setSessionId(null);
    setExperimentName(null);

    // Log session event for analytics
    if (activeId) {
      logSessionEvent('session_cleared', {
        conversationId: activeId,
      });
    }
  }, [activeId]);

  const messagesEndRef = useRef<HTMLDivElement>(null);
  const messagesContainerRef = useRef<HTMLDivElement>(null);
  const autoSpokenMessageIds = useRef<Set<string>>(new Set());
  const speakRef = useRef(speak);
  const lastScrolledMessagesLength = useRef<number>(0);
  const isStreamingRef = useRef(false); // Track if currently streaming to prevent effect loops
  // Removed unused refs (researchPollRef, deliveredResearchJobsRef)
  const initialConversationCreatedRef = useRef(false);

  // Keep speakRef updated
  useEffect(() => {
    speakRef.current = speak;
  }, [speak]);

  const isWidgetMode = !!widgetConfig;

  const { documents, refetch: refetchDocuments } = useDocuments({
    userId: userId || undefined,
    autoFetch: false // TEMPORARILY DISABLED TO DEBUG FREEZE
  });

  const processedDocs = useMemo(() => documents.filter(doc => doc.processed), [documents]);
  const processingDocs = useMemo(() => documents.filter(doc => !doc.processed), [documents]);
  const showDocumentStatus = enableDeepResearch && !isWidgetMode && !!user;

  // Debug logging for deep research status (moved to useEffect to prevent render loops)
  useEffect(() => {
    log.debug('Chat', 'Deep Research Status', {
      enableDeepResearch,
      isWidgetMode,
      hasUser: !!user,
      showDocumentStatus,
      processedDocsCount: processedDocs.length,
      processingDocsCount: processingDocs.length
    });
  }, [enableDeepResearch, isWidgetMode, user, showDocumentStatus, processedDocs.length, processingDocs.length]);

  // Debug logging for documents (moved to useEffect to prevent render loops)
  useEffect(() => {
    log.debug('Chat', 'Documents state', {
      count: documents.length,
      userId: userId,
      isWidgetMode,
      documents: documents.map(d => ({ id: d.id, filename: d.filename, processed: d.processed }))
    });
  }, [documents, userId, isWidgetMode]);

  const { archive: archiveConversation, loading: archiveLoading } = useArchive();

  // Memoize validation error callback to prevent infinite re-renders
  const handleValidationError = useCallback((conversation: any, result: any) => {
    log.error('Chat', 'Conversation validation failed', {
      conversationId: conversation.id,
      errors: result.errors,
      warnings: result.warnings,
      healthScore: result.healthScore,
    });
  }, []);

  // Conversation validation to prevent UI freezes from corrupted data
  const { validateMultiple, getHealthScore, isHealthy } = useConversationValidation({
    autoValidate: true,
    minHealthScore: 50,
    onValidationError: handleValidationError,
  });

  const handleCopyMessage = async (content: string, messageId: string) => {
    try {
      await navigator.clipboard.writeText(content);
      setCopiedMessageId(messageId);
      setTimeout(() => setCopiedMessageId(null), 2000);
    } catch (err) {
      log.error('Chat', 'Failed to copy message', { error: err });
    }
  };

  const handleToggleTTS = (messageId: string, content: string) => {
    log.debug('Chat', 'Toggle TTS for message', { messageId });

    // If this message is currently speaking
    if (speakingMessageId === messageId) {
      if (isSpeaking && !isPaused) {
        log.debug('Chat', 'Pausing TTS');
        pause();
      } else if (isPaused) {
        log.debug('Chat', 'Resuming TTS');
        resume();
      }
    } else {
      // Start speaking this message (cancels any other message)
      log.debug('Chat', 'Starting TTS for new message');
      setSpeakingMessageId(messageId);
      const speechOptions: SpeechOptions = selectedVoiceURI
        ? { voiceURI: selectedVoiceURI }
        : {};
      speak(content, speechOptions);
    }
  };

  const handleStopTTS = () => {
    log.debug('Chat', 'Stopping TTS');
    cancel();
    setSpeakingMessageId(null);
  };

  // Helper function to detect deep research results
  const isDeepResearchResult = (content: string): boolean => {
    // Deep research results are typically long and contain web search results
    const hasWebSearchIndicator = content.includes('üîß Using tool: web_search') ||
                                   content.toLowerCase().includes('based on the search results') ||
                                   content.toLowerCase().includes('comprehensive research');
    const isLongEnough = content.length > 1000; // Deep research results are substantial
    return hasWebSearchIndicator && isLongEnough;
  };

  // Handle email research - User will ask LLM naturally ("email this to...")
  const handleEmailResearch = (content: string) => {
    log.debug('Chat', 'Email research requested');
    // Note: The LLM handles this naturally via the intelligent_email tool
    // User can say "Email this research to sara@example.com"
    // For now, just copy to clipboard as a helpful fallback
    handleCopyMessage(content, 'deep-research-' + Date.now());
    alert('Research copied to clipboard. You can also ask me to email it by saying "Email this to [recipient]"');
  };

  // Handle download research as Markdown file
  const handleDownloadResearch = (content: string) => {
    log.debug('Chat', 'Download research requested');
    try {
      // Create a clean markdown version
      const markdown = content;
      const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `deep-research-${new Date().toISOString().split('T')[0]}.md`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      log.debug('Chat', 'Research downloaded successfully');
    } catch (err) {
      log.error('Chat', 'Failed to download research', { error: err });
      alert('Failed to download research. Please try copying it instead.');
    }
  };

  const scrollToBottom = useCallback(() => {
    // Use requestAnimationFrame to avoid layout thrashing
    requestAnimationFrame(() => {
      if (messagesContainerRef.current) {
        messagesContainerRef.current.scrollTop =
          messagesContainerRef.current.scrollHeight;
      }
      messagesEndRef.current?.scrollIntoView({
        behavior: "smooth",
        block: "end"
      });
    });
  }, []);

  useEffect(() => {
    // Only scroll if messages actually changed (new message added) and not currently streaming
    if (!isStreamingRef.current && messages.length > 0 && messages.length !== lastScrolledMessagesLength.current) {
      lastScrolledMessagesLength.current = messages.length;
      scrollToBottom();
    }
  }, [messages, scrollToBottom]);

  // DISABLED: Auto-speak should only be triggered manually via feedback icons, not automatically
  // This effect was causing UI freezes by running on every message update
  // Speech is handled by the manual speak button in MessageList feedback icons
  // useEffect(() => {
  //   if (!autoSpeakEnabled || !ttsSupported || isStreamingRef.current) return;
  //   // ... auto-speak logic removed to prevent UI blocking
  // }, [messages, autoSpeakEnabled, ttsSupported, isSpeaking, isPaused, selectedVoiceURI]);

  useEffect(() => {
    const loadTools = async () => {
      const { data, error: toolsError } = await getEnabledTools();
      if (toolsError) {
        log.error('Chat', 'Error loading tools', { error: toolsError });
        return;
      }
      const apiTools = data.map((tool) => ({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.parameters
        }
      }));
      setTools(apiTools);
      log.debug('Chat', 'Loaded tools', { count: apiTools.length });
    };
    loadTools();
  }, []);

  // Helper: Fetch research results and append to chat
  // Note: Research progress and results are now handled via SSE streaming (ResearchStreamViewer)
  // Legacy polling removed - research_progress events update state via handleSend streaming

  const fetchConversations = useCallback(async (): Promise<SidebarConversation[]> => {
    if (!userId || isWidgetMode) {
      setConversations([]);
      setActiveId("");
      return [];
    }

    try {
      log.debug('Chat', 'Fetching conversations for user', { userId });
      const { data, error: convoError } = await supabase
        .from("conversations")
        .select(
          "*, messages(count)"
        )
        .eq("user_id", userId)
        .eq("archived", false)
        .order("created_at", { ascending: false });

      if (convoError) {
        log.error('Chat', 'Error fetching conversations', { error: convoError });
        setError(`Failed to load conversations: ${convoError.message}`);
        setDebugInfo(`Supabase error: ${JSON.stringify(convoError)}`);
        setConversations([]);
        setActiveId("");
        return [];
      }

      const list = (data ?? []).map(conv => ({
        ...conv,
        message_count: Array.isArray(conv.messages) ? conv.messages[0]?.count || 0 : 0
      }));
      log.debug('Chat', 'Conversations fetched', { 
        count: list.length,
        conversationIds: list.map(c => c.id),
        messageCounts: list.map(c => ({ id: c.id, count: c.message_count }))
      });
      setConversations(list);
      setActiveId((prev) => {
        const newActiveId = prev && list.some((conv) => conv.id === prev) ? prev : (list.length > 0 ? list[0].id : "");
        log.debug('Chat', 'Setting activeId', { newActiveId, previousId: prev });
        return newActiveId;
      });

      if (list.length === 0) {
        setDebugInfo(`No conversations found. User ID: ${userId}`);
      } else {
        setDebugInfo("");
      }

      return list;
    } catch (err) {
      log.error('Chat', 'Unexpected error fetching conversations', { error: err });
      setError(
        `Unexpected error loading conversations: ${
          err instanceof Error ? err.message : String(err)
        }`
      );
      setConversations([]);
      setActiveId("");
      return [];
    }
  }, [userId, isWidgetMode]);

  const handleNewConversation = useCallback(async () => {
    log.debug('Chat', 'New Chat clicked', { hasUser: !!userId });
    if (!userId) {
      log.error('Chat', 'Cannot create conversation - no user');
      setError("You must be logged in to create a conversation");
      return;
    }

    try {
      log.debug('Chat', 'Creating new conversation for user', { userId });
      const { data, error: insertError } = await supabase
        .from("conversations")
        .insert({
          user_id: userId,
          title: "New Chat"
        })
        .select()
        .single();

      if (insertError) {
        log.error('Chat', 'Error creating conversation', { error: insertError });
        setError(`Failed to create conversation: ${insertError.message}`);
        return;
      }

      if (data) {
        log.debug('Chat', 'Successfully created conversation', { conversationId: data.id });
        setActiveId(data.id);
        setMessages([]);
        setError(null);
        await logSessionEvent(userId, "conversation_created", data.id);
        await fetchConversations();
      }
    } catch (err) {
      log.error('Chat', 'Unexpected error creating conversation', { error: err });
      setError(
        `Unexpected error: ${err instanceof Error ? err.message : String(err)}`
      );
    }
  }, [userId, fetchConversations]);

  useEffect(() => {
    log.trace('Chat', 'Initial conversation effect triggered', { 
      isWidgetMode, 
      userId, 
      alreadyCreated: initialConversationCreatedRef.current 
    });
    
    if (isWidgetMode) {
      log.trace('Chat', 'Skipping - widget mode');
      return;
    }

    // Only auto-create initial conversation once
    if (initialConversationCreatedRef.current) {
      log.trace('Chat', 'Skipping - initial conversation already created');
      return;
    }

    log.debug('Chat', 'Fetching conversations to check if we need to create initial');
    fetchConversations().then(async (list) => {
      log.debug('Chat', 'Fetch complete', { conversationCount: list.length });
      if (list.length === 0 && userId && !initialConversationCreatedRef.current) {
        log.debug('Chat', 'Creating initial conversation');
        initialConversationCreatedRef.current = true;
        await handleNewConversation();
      } else {
        log.debug('Chat', 'Skipping initial conversation creation - conversations exist or no userId');
      }
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isWidgetMode, userId]); // Removed fetchConversations and handleNewConversation to prevent loop

  // Load user settings on mount
  useEffect(() => {
    const loadSettings = async () => {
      if (!userId || !session?.access_token) {
        log.trace('Chat', 'Skipping settings load - no user or session');
        return;
      }

      try {
        log.debug('Chat', 'Loading user settings');
        const response = await fetch('/api/settings', {
          headers: {
            'Authorization': `Bearer ${session.access_token}`,
          },
        });

        if (!response.ok) {
          const errorText = await response.text();
          log.error('Chat', 'Settings API error', {
            status: response.status,
            statusText: response.statusText,
            body: errorText
          });
          throw new Error(`Failed to load settings: ${response.status} ${errorText}`);
        }

        const data = await response.json();

        if (data.settings) {
          log.debug('Chat', 'Settings loaded', { settings: data.settings });
          setUserSettings(data.settings);

          // Apply TTS settings
          if (data.settings.ttsVoiceUri) {
            setSelectedVoiceURI(data.settings.ttsVoiceUri);
          }
          setAutoSpeakEnabled(data.settings.ttsAutoPlay);
        } else {
          log.debug('Chat', 'No settings found, using defaults');
        }
      } catch (error) {
        log.error('Chat', 'Error loading settings', { error });
      }
    };

    loadSettings();
  }, [userId, session?.access_token]);

  useEffect(() => {
    log.trace('Chat', 'Message loading effect triggered', { hasUser: !!userId, activeId });
    
    if (!userId || !activeId) {
      log.trace('Chat', 'Skipping message load - missing user or activeId', { hasUser: !!userId, activeId });
      return;
    }

    // Skip retries if we already have a connection error to prevent spam
    if (connectionError) {
      log.debug('Chat', 'Skipping load due to connection error - user must refresh');
      return;
    }

    log.debug('Chat', 'Loading messages for conversation', { activeId });
    const startTime = Date.now();

    supabase
      .from("messages")
      .select("*")  // Select all columns to avoid missing field errors
      .eq("conversation_id", activeId)
      .order("created_at", { ascending: false })
      .limit(200)
      .then(({ data, error: msgError }) => {
        const loadTime = Date.now() - startTime;
        if (msgError) {
          // Check if it's a network error (Failed to fetch)
          const isNetworkError = msgError.message?.includes('Failed to fetch') || 
                                 msgError.message?.includes('NetworkError') ||
                                 !msgError.code;
          
          if (isNetworkError) {
            log.error('Chat', 'Network error loading messages - blocking retries', { error: msgError });
            setConnectionError(true);
            setError('Unable to connect to database. Please check your connection and refresh the page.');
          } else {
            log.error('Chat', 'Error loading messages', { error: msgError, details: JSON.stringify(msgError, null, 2) });
            setError(`Failed to load messages: ${msgError.message || 'Unknown error'}`);
          }
          return;
        }
        log.debug('Chat', 'Loaded messages', { count: data?.length || 0, loadTimeMs: loadTime });
        if (data) {
          log.debug('Chat', 'Setting messages state');
          
          // Log message sizes to identify large content
          const messageSizes = data.map((m, idx) => ({
            index: idx,
            id: m.id,
            role: m.role,
            contentLength: m.content?.length || 0
          }));
          log.debug('Chat', 'Message sizes', { sizes: messageSizes });
          
          const totalContentSize = messageSizes.reduce((sum, m) => sum + m.contentLength, 0);
          log.debug('Chat', 'Total content size', { totalCharacters: totalContentSize });
          
          // Warn about very large messages
          const largeMessages = messageSizes.filter(m => m.contentLength > 10000);
          if (largeMessages.length > 0) {
            log.warn('Chat', 'Found large messages (>10KB)', { count: largeMessages.length, messages: largeMessages });
          }
          
          // Truncate extremely large messages to prevent freeze
          const processedMessages = data.map(msg => {
            if (msg.content && msg.content.length > 50000) {
              log.warn('Chat', 'Truncating message due to size', { 
                messageId: msg.id, 
                originalLength: msg.content.length, 
                truncatedTo: 50000 
              });
              return {
                ...msg,
                content: msg.content.substring(0, 50000) + '\n\n... [Message truncated due to size. Original length: ' + msg.content.length + ' characters]'
              };
            }
            return msg;
          });
          


          // Validate messages to prevent corrupted data from freezing UI

          const conversationData = {

            id: activeId,

            user_id: userId,

            created_at: new Date().toISOString(),

            messages: processedMessages.map(msg => ({

              id: msg.id,

              role: msg.role,

              content: msg.content,

              metadata: msg.metadata,

              content_json: msg.content_json,

              tools_called: msg.tools_called,

            })),

          };



          const validationResult = validateMultiple([conversationData]);



          if (validationResult.invalid.length > 0) {

            log.error('Chat', 'Messages failed validation', {

              conversationId: activeId,

              invalidCount: validationResult.invalid.length,

              summary: validationResult.summary,

            });



            // Show error if health score is too low

            if (validationResult.summary.averageHealthScore < 30) {

              setError('This conversation contains corrupted data and cannot be displayed safely. Please archive it and start a new conversation.');

              return;

            }

          }



          // Use validated messages if available

          const validatedMessages = validationResult.valid.length > 0

            ? validationResult.valid[0].messages || processedMessages

            : processedMessages;
          // Reverse to show oldest first (most recent 50 messages in chronological order)
          setMessages([...validatedMessages].reverse());
          log.debug('Chat', 'Messages state updated');
        }
      });

    supabase
      .from("feedback")
      .select("response_id, value")
      .eq("user_id", userId)
      .eq("conversation_id", activeId)
      .then(({ data, error: feedbackError }) => {
        if (feedbackError) {
          // Check if it's a network error
          const isNetworkError = feedbackError.message?.includes('Failed to fetch') || 
                                 feedbackError.message?.includes('NetworkError') ||
                                 !feedbackError.code;
          
          if (isNetworkError && !connectionError) {
            log.error('Chat', 'Network error loading feedback - blocking retries', { error: feedbackError });
            setConnectionError(true);
          } else if (!isNetworkError) {
            log.error('Chat', 'Error loading feedback', { error: feedbackError });
          }
          // Skip logging if connectionError already set to avoid spam
          return;
        }
        if (data) {
          const feedbackMap: { [key: string]: number } = {};
          data.forEach((item: { response_id: string; value: number }) => {
            feedbackMap[item.response_id] = item.value;
          });
          setFeedback(feedbackMap);
        }
      });
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [userId, activeId, connectionError]);

  useEffect(() => {
    const handleClickOutside = () => {
      if (openMenuId) {
        setOpenMenuId(null);
      }
    };

    document.addEventListener("click", handleClickOutside);
    return () => document.removeEventListener("click", handleClickOutside);
  }, [openMenuId]);

  // Initialize or reset context tracker when conversation changes
  useEffect(() => {
    if (!activeId) {
      log.debug('Chat', 'No active conversation, clearing context tracker');
      contextTrackerRef.current = null;
      setContextUsage(null);
      return;
    }

    const maxTokens = selectedModel?.context_length || 128000; // Increased from 8000 to match modern models
    const modelName = selectedModel?.name || 'Moderator';
    const modelId = selectedModelId === '__default__' ? null : selectedModelId;

    log.debug('Chat', 'Initializing context tracker', {
      conversationId: activeId,
      modelId,
      modelName,
      maxTokens,
      usingFallback: !selectedModel?.context_length
    });

    // Initialize context tracker
    const tracker = new ContextTracker(
      activeId,
      modelId,
      maxTokens,
      {},
      modelName
    );

    // Fetch and restore context from database using Supabase
    supabase
      .from('conversation_model_contexts')
      .select('*')
      .eq('conversation_id', activeId)
      .order('last_message_at', { ascending: false }).limit(25).then(({ data: contexts, error }) => {
        if (error) {
          log.error('Chat', 'Error fetching context', { error });
          contextTrackerRef.current = tracker;
          setContextUsage(tracker.getUsage());
          return;
        }

        if (contexts && contexts.length > 0) {
          log.debug('Chat', 'Restoring context from database', {
            contextCount: contexts.length,
            contexts: contexts.map((c: { model_id: string; total_tokens?: number }) => ({
              modelId: c.model_id,
              totalTokens: c.total_tokens
            }))
          });

          // Restore each model's context
          contexts.forEach((record) => {
            const typedRecord = record as unknown as ConversationModelContextRecord;
            const recordModelName = typedRecord.model_id === modelId ? modelName : typedRecord.model_id;
            tracker.restoreFromDatabase(typedRecord, maxTokens, recordModelName);
          });

          contextTrackerRef.current = tracker;
          setContextUsage(tracker.getUsage());
        } else {
          log.debug('Chat', 'No existing context found, starting fresh');
          contextTrackerRef.current = tracker;
          setContextUsage(tracker.getUsage());
        }
      });
  }, [activeId, selectedModelId, selectedModel]);

  const handleFeedback = async (messageId: string, value: number) => {
    if (!user) return;

    try {
      const { error: feedbackError } = await supabase.from("feedback").upsert({
        user_id: user.id,
        conversation_id: activeId,
        response_id: messageId,
        value: value
      });

      if (!feedbackError) {
        setFeedback((prev) => ({ ...prev, [messageId]: value }));
        await logSessionEvent(user.id, "feedback_given", activeId);
      }
    } catch (err) {
      log.error('Chat', 'Error submitting feedback', { error: err });
    }
  };

  const handleArchiveConversation = async (conversationId: string) => {
    if (!userId || !user) {
      setError("You must be logged in to archive conversations");
      return;
    }

    try {
      setArchivingId(conversationId);
      await archiveConversation({ conversationIds: [conversationId] });
      setDebugInfo(`Conversation archived: ${conversationId}`);

      if (activeId === conversationId) {
        setActiveId("");
        setMessages([]);
      }

      await fetchConversations();
    } catch (err) {
      log.error('Chat', 'Archive error', { error: err, conversationId });
      setError(
        `Failed to archive conversation: ${
          err instanceof Error ? err.message : String(err)
        }`
      );
    } finally {
      setArchivingId(null);
      setOpenMenuId(null);
    }
  };

  const handleBulkArchive = async () => {
    if (!userId || !user) {
      setError("You must be logged in to archive conversations");
      return;
    }

    const count = selectedConvIds.size;
    const idsToArchive = Array.from(selectedConvIds);
    log.debug('Chat', 'Bulk archive started', { count, conversationIds: idsToArchive });

    try {
      await archiveConversation({ conversationIds: idsToArchive });
      log.debug('Chat', 'Successfully archived conversations', { count });

      if (activeId && selectedConvIds.has(activeId)) {
        setActiveId('');
        setMessages([]);
      }

      setSelectedConvIds(new Set());
      setSelectMode(false);
      await fetchConversations();
    } catch (err) {
      log.error('Chat', 'Bulk archive error', { error: err, count });
      setError(
        `Failed to archive conversations: ${
          err instanceof Error ? err.message : String(err)
        }`
      );
    }
  };

  const handlePromoteConversation = async (conversationId: string) => {
    if (!user || isWidgetMode) return;

    try {
      setLoading(true);
      log.debug('Chat', 'Promoting conversation', { conversationId });

      const {
        data: { session }
      } = await supabase.auth.getSession();
      const authToken = session?.access_token;
      if (!authToken) {
        throw new Error("No auth token available");
      }

      const response = await fetch("/api/conversations/promote", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${authToken}`
        },
        body: JSON.stringify({ conversationId })
      });

      if (!response.ok) {
        const errorBody = await response.json();
        throw new Error(errorBody.error || "Failed to promote");
      }

      const result = await response.json();
      log.debug('Chat', 'Conversation promoted successfully', { result });

      setConversations((prev) =>
        prev.map((c) =>
          c.id === conversationId
            ? {
                ...c,
                in_knowledge_graph: true,
                promoted_at: new Date().toISOString()
              }
            : c
        )
      );
    } catch (err) {
      log.error('Chat', 'Promotion error', { error: err });
      setError(
        err instanceof Error ? err.message : "Failed to promote conversation"
      );
    } finally {
      setLoading(false);
      setOpenMenuId(null);
    }
  };

  const handleDeleteConversation = async (conversationId: string) => {
    if (!user) return;

    try {
      log.debug('Chat', 'Deleting conversation', { conversationId });

      const { error: deleteError } = await supabase
        .from("conversations")
        .delete()
        .eq("id", conversationId)
        .eq("user_id", user.id);

      if (deleteError) {
        throw new Error(deleteError.message);
      }

      setConversations((prev) => prev.filter((c) => c.id !== conversationId));

      if (activeId === conversationId) {
        setActiveId("");
        setMessages([]);
      }

      await fetchConversations();
      await logSessionEvent(user.id, "conversation_deleted", conversationId);
    } catch (err) {
      log.error('Chat', 'Delete error', { error: err, conversationId });
      setError(
        err instanceof Error ? err.message : "Failed to delete conversation"
      );
    } finally {
      setOpenMenuId(null);
    }
  };

  const handleBulkDelete = async () => {
    if (!user) return;

    const count = selectedConvIds.size;
    log.debug('Chat', 'Bulk delete started', { count });

    const idsToDelete = Array.from(selectedConvIds);
    let successCount = 0;
    let errorCount = 0;
    const deletedIds: string[] = [];

    for (const convId of idsToDelete) {
      try {
        log.debug('Chat', 'Deleting conversation', { conversationId: convId });

        const { error: deleteError } = await supabase
          .from('conversations')
          .delete()
          .eq('id', convId)
          .eq('user_id', user.id);

        if (deleteError) {
          throw new Error(deleteError.message);
        }

        successCount++;
        deletedIds.push(convId);
        log.debug('Chat', 'Successfully deleted conversation', { conversationId: convId });
        await logSessionEvent(user.id, 'conversation_deleted', convId);
      } catch (err) {
        errorCount++;
        log.error('Chat', 'Failed to delete conversation', { conversationId: convId, error: err });
      }
    }

    setConversations((prev) => prev.filter((c) => !deletedIds.includes(c.id)));

    if (activeId && deletedIds.includes(activeId)) {
      setActiveId('');
      setMessages([]);
    }

    setSelectedConvIds(new Set());
    setSelectMode(false);

    log.debug('Chat', 'Bulk delete complete', { successCount, errorCount });

    if (errorCount > 0) {
      setError(`Deleted ${successCount} conversations. ${errorCount} failed.`);
    }

    await fetchConversations();
  };

  const handleSend = async () => {
    log.debug('Chat', 'handleSend called', { 
      inputPreview: input.trim().substring(0, 20), 
      hasUser: !!user, 
      activeId 
    });

    if (!input.trim()) {
      setError("Please enter a message");
      return;
    }

    if (!user) {
      setError("You must be logged in to send messages");
      return;
    }

    if (!activeId) {
      setError("Please create or select a conversation first");
      return;
    }

    setError(null);
    setLoading(true);
    isStreamingRef.current = true; // Mark as streaming to prevent effect loops

    const controller = new AbortController();
    setAbortController(controller);

    const userMessage = input;
    setInput("");

    // [UI_FREEZE_FIX] Create optimistic user message immediately (non-blocking)
    const tempUserMessageId = `temp-user-${Date.now()}`;
    const optimisticUserMessage = {
      id: tempUserMessageId,
      conversation_id: activeId,
      user_id: user.id,
      role: "user" as const,
      content: userMessage,
      created_at: new Date().toISOString()
    };
    
    // Add optimistic message to UI immediately
    setMessages((msgs) => [...msgs, optimisticUserMessage]);

    // [UI_FREEZE_FIX] Save user message to database in background (non-blocking)
    // Don't await - let it complete in the background while UI stays responsive
    void supabase
      .from("messages")
      .insert({
        conversation_id: activeId,
        user_id: user.id,
        role: "user",
        content: userMessage
      })
      .select()
      .single()
      .then(({ data: msgData, error }) => {
        if (error) {
          log.error('Chat', 'Failed to save user message', { error });
        } else if (msgData) {
          // Replace temp message with real one from database
          setMessages((msgs) => msgs.map(m => 
            m.id === tempUserMessageId ? msgData : m
          ));
          
          // [UI_FREEZE_FIX] Update conversation title in background (non-blocking)
          if (messages.length === 0) {
            supabase
              .from("conversations")
              .update({
                title: userMessage.slice(0, 50) + (userMessage.length > 50 ? "..." : "")
              })
              .eq("id", activeId)
              .then(({ error: titleError }) => {
                if (titleError) {
                  log.error('Chat', 'Failed to update conversation title', { error: titleError });
                }
              });
          }
        }
        return msgData;
      });

    // Use optimistic message for API call (will be replaced with real one when DB responds)
    const msgData = optimisticUserMessage;

    // [UI_FREEZE_FIX] Declare throttle variable before try block so it's accessible in catch
    let updateThrottle: NodeJS.Timeout | null = null;
    const THROTTLE_MS = 500;

    try {
      const conversationMessages = [...messages, msgData].map((m) => ({
        role: m.role,
        content: m.content
      }));

      log.debug('Chat', 'Calling OpenAI API', { 
        messageCount: conversationMessages.length 
      });

      // [WEB_SEARCH] Modify web_search tool - always summarize, optionally deep research
      const modifiedTools = tools.map(tool => {
        if (tool.function.name === 'web_search') {
          let description = tool.function.description;

          // Always enable summarization for better quality results
          description += ' IMPORTANT: Always set summarize=true for enhanced results.';

          // Conditionally enable deep research based on toggle
          if (enableDeepResearch) {
            description += ' IMPORTANT: Deep research mode is ON - you MUST set deepResearchConfirmed=true.';
          }

          return {
            ...tool,
            function: {
              ...tool.function,
              description
            }
          };
        }
        return tool;
      });

      // Track latency for analytics
      const streamStartTime = Date.now();

      const response = await fetch("/api/chat", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: conversationMessages,
          tools: modifiedTools,
          conversationId: activeId,
          modelId: selectedModelId === '__default__' ? null : selectedModelId
        }),
        signal: controller.signal
      });

      if (!response.ok) {
        const errorText = await response.text();
        log.error('Chat', 'API error', { status: response.status, errorText });
        throw new Error(`API request failed: ${response.status} ${errorText}`);
      }

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();
      let assistantMessage = "";
      let graphragCitations: Citation[] | undefined;
      let graphragContextsUsed: number | undefined;
      const tempMessageId = "temp-" + Date.now();

      let modelId: string | null = null;
      let provider: string | null = null;
      let deepResearchDetected = false; // Track if we've already detected deep research to avoid repeated regex

      // Helper function to update message with throttling
      const updateMessageThrottled = () => {
        if (updateThrottle) clearTimeout(updateThrottle);

        updateThrottle = setTimeout(() => {
          setMessages((msgs) =>
            msgs.map((m) =>
              m.id === tempMessageId
                ? {
                    ...m,
                    content: assistantMessage,
                    citations: graphragCitations,
                    contextsUsed: graphragContextsUsed
                  }
                : m
            )
          );
        }, THROTTLE_MS);
      };

      setMessages((msgs) => [
        ...msgs,
        {
          id: tempMessageId,
          role: "assistant",
          content: ""
        }
      ]);

      if (reader) {
        log.debug('Chat', 'Starting stream read');
        streamLoop: while (true) {
          const { done, value } = await reader.read();
          if (done) {
            log.debug('Chat', 'Stream done', { totalMessageLength: assistantMessage.length });
            break streamLoop;
          }

          const chunk = decoder.decode(value);
          const lines = chunk.split("\n");

          for (const line of lines) {
            if (!line.startsWith("data: ")) continue;

            const data = line.slice(6);
            if (data === "[DONE]") {
              log.debug('Chat', 'Received [DONE] marker');
              break streamLoop;
            }

            try {
              const parsed = JSON.parse(data);
              if (parsed.type === "graphrag_metadata") {
                graphragCitations = parsed.citations;
                graphragContextsUsed = parsed.contextsUsed;

                // Note: graphrag_tokens will come in token_usage event, not here
                log.debug('Chat', 'GraphRAG metadata received', {
                  citationsCount: graphragCitations?.length || 0,
                  contextsUsed: graphragContextsUsed || 0
                });

                // Don't update state immediately - will be batched with next content update
                // This prevents extra re-renders during streaming
              }

              if (parsed.content) {
                assistantMessage += parsed.content;
                log.trace('Chat', 'Received content chunk', { totalLength: assistantMessage.length });
                // [UI_FREEZE_FIX] Use throttled update instead of immediate
                updateMessageThrottled();

                // Detect deep research start (only check once to avoid blocking main thread with repeated regex)
                if (!deepResearchDetected && assistantMessage.includes("deep_research_started")) {
                  deepResearchDetected = true;
                  const jobIdMatch = assistantMessage.match(/jobId['":\s]+([a-f0-9-]+)/i);
                  const queryMatch = assistantMessage.match(/for\s+["']([^"']+)["']|query['":\s]+["']([^"']+)["']/i);
                  if (jobIdMatch) {
                    const jobId = jobIdMatch[1];
                    const query = queryMatch ? (queryMatch[1] || queryMatch[2] || 'Research Query') : 'Research Query';
                    log.debug('Chat', 'Deep research started', { jobId, query });

                    // Set legacy research progress (for backward compatibility)
                    setResearchProgress({
                      jobId,
                      status: 'running',
                      currentStep: 'Starting research...',
                      totalSteps: 4,
                      completedSteps: 0
                    });

                    // Set structured research job (v2 with SSE streaming)
                    setActiveResearchJob({
                      jobId,
                      query
                    });
                  }
                }
              }

  // OBSERVABILITY: Handle server-side research progress events
  if (parsed.type === "research_progress") {
                log.debug('Chat', 'Research progress event', { event: parsed });
                setResearchProgress({
                  jobId: parsed.jobId || researchProgress?.jobId || 'unknown',
                  status: parsed.status || 'running',
                  currentStep: parsed.currentStep || researchProgress?.currentStep || 'In progress...',
                  totalSteps: parsed.totalSteps || researchProgress?.totalSteps || 4,
                  completedSteps: parsed.completedSteps ?? researchProgress?.completedSteps ?? 0,
                });
  }

              // Phase 3: progressive per-document summaries (previews before final answer)
              if (parsed.type === "doc_summary") {
                const title = parsed.title || 'Document';
                const url = parsed.url || '';
                const summary = parsed.summary || '';
                const line = `\n‚Ä¢ ${title}${url ? ` (${url})` : ''}\n   ${summary}\n`;
                assistantMessage += line;
                updateMessageThrottled();
              }

              if (parsed.type === "model_metadata") {
                modelId = parsed.model_id;
                provider = parsed.provider;
              }

              if (parsed.type === "tool_call") {
                const toolInfo = `\n\nüîß Using tool: ${parsed.tool_name}\n`;
                assistantMessage += toolInfo;
                // [UI_FREEZE_FIX] Use throttled update instead of immediate
                updateMessageThrottled();
              }

              if (parsed.type === "tool_result") {
                const resultInfo = `üìä Result: ${JSON.stringify(
                  parsed.result
                )}\n\n`;
                assistantMessage += resultInfo;
                // [UI_FREEZE_FIX] Use throttled update instead of immediate
                updateMessageThrottled();
              }

              // Capture token usage for context tracking
              if (parsed.type === "token_usage" && contextTrackerRef.current) {
                const inputTokens = parsed.input_tokens || 0;
                const outputTokens = parsed.output_tokens || 0;
                const graphragTokens = parsed.graphrag_tokens || 0;

                log.debug('Chat', 'Token usage received', {
                  input: inputTokens,
                  output: outputTokens,
                  graphrag: graphragTokens
                });

                const updatedUsage = contextTrackerRef.current.addMessage(
                  inputTokens,
                  outputTokens,
                  graphragTokens
                );
                setContextUsage(updatedUsage);

                // Save context to database using Supabase
                // Only save if there's a valid model UUID (not '__default__')
                // Validate that selectedModelId is a valid UUID format
                const isValidUUID = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(selectedModelId);
                
                if (selectedModelId !== '__default__' && activeId && isValidUUID) {
                  const activeContext = contextTrackerRef.current.getModelContext(
                    selectedModelId === '__default__' ? null : selectedModelId
                  );

                  if (activeContext) {
                    log.debug('Chat', 'Saving context for model', { modelId: selectedModelId });
                    supabase
                      .from('conversation_model_contexts')
                      .upsert({
                        conversation_id: activeId,
                        model_id: selectedModelId, // Use selectedModelId directly (it's a UUID)
                        total_tokens: activeContext.totalTokens,
                        input_tokens: activeContext.inputTokens,
                        output_tokens: activeContext.outputTokens,
                        graphrag_tokens: activeContext.graphragTokens,
                        message_count: activeContext.messageCount,
                        first_message_at: activeContext.firstMessageAt?.toISOString(),
                        last_message_at: activeContext.lastMessageAt?.toISOString(),
                      }, {
                        onConflict: 'conversation_id,model_id'
                      })
                      .then(({ error }) => {
                        if (error) {
                          log.error('Chat', 'Error saving context', { 
                            error, 
                            modelId: selectedModelId,
                            conversationId: activeId,
                            errorCode: error.code,
                            errorMessage: error.message,
                            errorDetails: error.details,
                            errorHint: error.hint
                          });
                        } else {
                          log.debug('Chat', 'Context saved to database');
                        }
                      });
                  }
                } else {
                  if (selectedModelId !== '__default__' && !isValidUUID) {
                    log.warn('Chat', 'Skipping context save - invalid model UUID format', { modelId: selectedModelId });
                  } else {
                    log.debug('Chat', 'Skipping context save - no specific model selected (using __default__)');
                  }
                }
              }
            } catch (err) {
              log.warn('Chat', 'Skipping invalid JSON chunk', { error: err });
            }
          }
        }
      }

      // [UI_FREEZE_FIX] Clear throttle and do final immediate update
      if (updateThrottle) {
        clearTimeout(updateThrottle);
        updateThrottle = null;
      }

      // Final immediate update to ensure last chunk is displayed
      log.debug('Chat', 'Final update', { 
        messageLength: assistantMessage.length, 
        preview: assistantMessage.substring(0, 200) 
      });
      setMessages((msgs) =>
        msgs.map((m) =>
          m.id === tempMessageId
            ? {
                ...m,
                content: assistantMessage,
                citations: graphragCitations,
                contextsUsed: graphragContextsUsed
              }
            : m
        )
      );

      // Calculate latency and estimate tokens for analytics
      const streamLatencyMs = Date.now() - streamStartTime;
      const estimatedOutputTokens = Math.ceil(assistantMessage.length / 4);
      const estimatedInputTokens = Math.ceil(userMessage.length / 4);

      log.debug('Chat', 'Stream metrics', {
        latencyMs: streamLatencyMs,
        estimatedInputTokens,
        estimatedOutputTokens
      });

      // Save message to database in background - DON'T WAIT FOR IT
      // Message is already visible with content, just update ID later
      log.debug('Chat', 'Starting database save', { tempMessageId, contentLength: assistantMessage.length });
      supabase
        .from("messages")
        .insert({
          conversation_id: activeId,
          user_id: user.id,
          role: "assistant",
          content: assistantMessage,
          model_id: modelId,
          provider: provider,
          latency_ms: streamLatencyMs,
          input_tokens: estimatedInputTokens,
          output_tokens: estimatedOutputTokens
        })
        .select()
        .single()
        .then(({ data: aiMsg, error: dbError }) => {
          if (dbError) {
            log.error('Chat', 'Failed to save message', { error: dbError });
          } else {
            log.debug('Chat', 'Message saved to DB', { messageId: aiMsg?.id });
            if (aiMsg) {
              setMessages((msgs) =>
                msgs.map((m) =>
                  m.id === tempMessageId
                    ? {
                        ...aiMsg,
                        citations: graphragCitations,
                        contextsUsed: graphragContextsUsed
                      }
                    : m
                )
              );
            }
          }
        });
    } catch (err) {
      // [UI_FREEZE_FIX] Clear any pending throttle on error
      if (updateThrottle) {
        clearTimeout(updateThrottle);
      }

      if (err instanceof Error && err.name === 'AbortError') {
        log.debug('Chat', 'Request cancelled by user');
        setMessages((msgs) => msgs.filter((m) => !m.id.startsWith("temp-")));
      } else {
        log.error('Chat', 'Error getting AI response', { error: err });
        const errorMessage =
          err instanceof Error ? err.message : String(err);
        setError(`Failed to get AI response: ${errorMessage}`);
        setMessages((msgs) => msgs.filter((m) => !m.id.startsWith("temp-")));
      }
    }

    setLoading(false);
    setAbortController(null);
    isStreamingRef.current = false; // Streaming complete, allow effects to run

    // Trigger scroll after streaming completes
    scrollToBottom();
  };

  const handleStop = () => {
    log.debug('Chat', 'Stopping message generation');
    if (abortController) {
      abortController.abort();
      setAbortController(null);
      setLoading(false);
    }
  };

  const handleToggleSelection = (convId: string) => {
    log.debug('Chat', 'Toggling selection for conversation', { conversationId: convId });
    setSelectedConvIds((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(convId)) {
        log.debug('Chat', 'Removing from selection', { conversationId: convId });
        newSet.delete(convId);
      } else {
        log.debug('Chat', 'Adding to selection', { conversationId: convId });
        newSet.add(convId);
      }
      log.debug('Chat', 'Total selected', { count: newSet.size });
      return newSet;
    });
  };

  const handleModelChange = (modelId: string, model?: { id: string; name: string; context_length: number }) => {
    log.debug('Chat', 'Model changed', { modelId, modelName: model?.name, contextLength: model?.context_length });
    setSelectedModelId(modelId);
    setSelectedModel(model || null);

    // Switch model in context tracker if it exists
    if (contextTrackerRef.current && activeId) {
      const maxTokens = model?.context_length || 128000; // Increased from 8000 to match modern models
      const modelName = model?.name || 'Moderator';
      log.debug('Chat', 'Switching context tracker to model', { 
        modelId, 
        modelName, 
        maxTokens, 
        usingFallback: !model?.context_length 
      });
      contextTrackerRef.current.switchModel(modelId === '__default__' ? null : modelId, maxTokens, modelName);
      setContextUsage(contextTrackerRef.current.getUsage());
    }
  };

  const hasActiveConversation = !!activeId;
  const sidebarMenuItems = [
    {
      id: "settings",
      label: "Settings",
      icon: Settings,
      onClick: () => setOpenModal('settings'),
      disabled: false
    },
    {
      id: "archive-manager",
      label: "Archived Conversations",
      icon: Archive,
      onClick: () => setOpenModal('archive-manager'),
      disabled: archiveLoading
    },
    {
      id: "context-inspector",
      label: "Context Inspector",
      icon: Search,
      onClick: () => setOpenModal('context-inspector'),
      disabled: !hasActiveConversation
    },
    {
      id: "model-comparison",
      label: "Compare Models",
      icon: RefreshCw,
      onClick: () => setOpenModal('model-comparison'),
      disabled: false
    },
    {
      id: "export-conversation",
      label: "Export Conversation",
      icon: Download,
      onClick: () => setOpenModal('export-dialog'),
      disabled: !hasActiveConversation
    },
    {
      id: "knowledge-base",
      label: "Add to KGraph",
      icon: Database,
      onClick: () => setOpenModal('knowledge-base'),
      badge: documents.length > 0 ? String(documents.length) : undefined
    }
  ];

  const filteredConversations = useMemo(() => {
    const query = searchQuery.trim().toLowerCase();
    if (!query) {
      return conversations;
    }
    return conversations.filter((conv) =>
      conv.title.toLowerCase().includes(query)
    );
  }, [conversations, searchQuery]);

  return (
    <div className="flex h-screen overflow-hidden bg-background">
      {/* Command Palette - Ctrl+K / Cmd+K */}
      <ChatCommandPalette
        conversations={conversations}
        models={availableModels}
        onNewConversation={() => setActiveId("")}
        onSelectConversation={(id) => setActiveId(id)}
        onSelectModel={(id) => {
          const model = availableModels.find(m => m.id === id);
          if (model) {
            setSelectedModelId(id);
            setSelectedModel({ ...model, context_length: 128000 }); // Default context length
          }
        }}
        onOpenArchive={() => setOpenModal('archive-manager')}
        onOpenKnowledgeBase={() => setOpenModal('knowledge-base')}
        onOpenSettings={() => setOpenModal('settings')}
        onOpenContextInspector={() => setOpenModal('context-inspector')}
        onOpenModelComparison={() => setOpenModal('model-comparison')}
        onExport={() => setOpenModal('export-dialog')}
        onDeleteConversation={() => setOpenModal('delete-confirm')}
      />

      {error && (
        <div className="fixed top-0 left-0 right-0 z-50 bg-red-50 border-b border-red-200 p-4">
          <div className="max-w-4xl mx-auto flex items-center justify-between">
            <div className="flex items-center space-x-3">
              <span className="text-2xl">‚ö†Ô∏è</span>
              <div>
                <p className="font-semibold text-red-800">Error</p>
                <p className="text-sm text-red-700">{error}</p>
              </div>
            </div>
            <button
              onClick={() => setError(null)}
              className="text-red-600 hover:text-red-800 font-bold"
            >
              ‚úï
            </button>
          </div>
        </div>
      )}

      {debugInfo && !error && (
        <div className="fixed top-0 left-0 right-0 z-50 bg-blue-50 border-b border-blue-200 p-3">
          <div className="max-w-4xl mx-auto flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <span className="text-lg">üêõ</span>
              <p className="text-sm text-blue-800">{debugInfo}</p>
            </div>
            <button
              onClick={() => setDebugInfo("")}
              className="text-blue-600 hover:text-blue-800 text-sm"
            >
              ‚úï
            </button>
          </div>
        </div>
      )}

      {user && !isWidgetMode && (
        <AppSidebar
          currentPage="chat"
          user={user}
          signOut={signOut}
          menuItems={sidebarMenuItems}
          onNewConversation={handleNewConversation}
          onPromoteConversation={handlePromoteConversation}
          onArchiveConversation={handleArchiveConversation}
          onDeleteConversation={handleDeleteConversation}
          onBulkArchive={() => {
            // AppSidebar may pass IDs, but our handleBulkArchive uses selectedConvIds from state
            handleBulkArchive();
          }}
          modelSelector={
            <ModelSelector
              value={selectedModelId}
              onChange={handleModelChange}
              sessionToken={session?.access_token}
              disabled={loading}
            />
          }
        >
          <div className="h-full flex flex-col gap-3">
            <div>
              <span className="block text-xs font-semibold text-muted-foreground uppercase tracking-wide mb-2">
                Conversations
              </span>
            </div>

            <button
              onClick={(event) => {
                event.stopPropagation();
                const newMode = !selectMode;
                log.debug('Chat', 'Toggling select mode', { from: selectMode, to: newMode });
                setSelectMode(newMode);
                if (!newMode) {
                  // Exiting select mode, clear selections
                  log.debug('Chat', 'Clearing selections on mode exit');
                  setSelectedConvIds(new Set());
                }
              }}
              className="w-full text-left px-2.5 py-1.5 text-xs rounded-md flex items-center gap-2 transition-colors cursor-pointer hover:bg-muted"
            >
              <CheckSquare className="w-3.5 h-3.5" />
              <span>{selectMode ? 'Cancel' : 'Select'}</span>
            </button>

            {selectedConvIds.size > 0 && (
              <>
                <button
                  onClick={(event) => {
                    event.stopPropagation();
                    log.debug('Chat', 'Archive Selected button clicked', { count: selectedConvIds.size });
                    handleBulkArchive();
                  }}
                  className="w-full text-left px-2.5 py-1.5 text-xs rounded-md flex items-center gap-2 transition-colors cursor-pointer bg-blue-50 text-blue-700 hover:bg-blue-100"
                >
                  <Archive className="w-3.5 h-3.5" />
                  <span>Archive Selected ({selectedConvIds.size})</span>
                </button>
                <button
                  onClick={(event) => {
                    event.stopPropagation();
                    log.debug('Chat', 'Delete Selected button clicked, showing confirmation', { count: selectedConvIds.size });
                    setOpenModal('delete-confirm');
                  }}
                  className="w-full text-left px-2.5 py-1.5 text-xs rounded-md flex items-center gap-2 transition-colors cursor-pointer bg-destructive/10 text-destructive hover:bg-destructive/20"
                >
                  <Trash2 className="w-3.5 h-3.5" />
                  <span>Delete Selected ({selectedConvIds.size})</span>
                </button>
              </>
            )}

            <button
              onClick={(event) => {
                event.stopPropagation();
                if (messages.length > 0) {
                  handleNewConversation();
                }
              }}
              disabled={messages.length === 0}
              className={`w-full text-left px-2.5 py-1.5 text-xs rounded-md flex items-center gap-2 transition-colors ${
                messages.length === 0
                  ? "opacity-50 cursor-not-allowed"
                  : "cursor-pointer hover:bg-muted"
              }`}
              title={messages.length === 0 ? "Send a message first to create a conversation" : "Create new chat"}
            >
              <MessageSquare className="w-3.5 h-3.5" />
              <span>New Chat</span>
            </button>

            {!searchExpanded ? (
              <button
                onClick={(event) => {
                  event.stopPropagation();
                  setSearchExpanded(true);
                }}
                className="w-full text-left px-2.5 py-1.5 text-xs rounded-md flex items-center gap-2 transition-colors cursor-pointer hover:bg-muted"
              >
                <Search className="w-3.5 h-3.5" />
                <span>Search</span>
              </button>
            ) : (
              <div className="relative">
                <Search className="absolute left-2 top-1/2 -translate-y-1/2 w-3.5 h-3.5 text-muted-foreground" />
                <input
                  type="text"
                  value={searchQuery}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) => setSearchQuery(e.target.value)}
                  onBlur={() => {
                    if (!searchQuery) {
                      setSearchExpanded(false);
                    }
                  }}
                  placeholder="Search conversations"
                  autoFocus
                  className="w-full pl-8 pr-3 py-1.5 text-sm bg-muted/50 border-0 rounded-md focus:outline-none focus:ring-1 focus:ring-ring placeholder:text-muted-foreground"
                />
              </div>
            )}

            <div className="border-t border-border pt-3"></div>

            <div className="flex-1 min-h-0 space-y-1">
              {filteredConversations.length === 0 ? (
                <p className="text-sm text-muted-foreground px-2 py-4">
                  {conversations.length === 0
                    ? "No conversations yet."
                    : "No matches found."}
                </p>
              ) : (
                filteredConversations.map((conv) => (
                  <div
                    key={conv.id}
                    className="group relative rounded-md border border-transparent transition-colors"
                  >
                    <div
                      onClick={() => {
                        if (selectMode) {
                          handleToggleSelection(conv.id);
                        } else {
                          setActiveId(conv.id);
                        }
                      }}
                      className={`flex items-center justify-between px-2.5 py-1.5 text-xs cursor-pointer rounded-md ${
                        activeId === conv.id && !selectMode
                          ? "bg-accent text-accent-foreground font-medium border-accent"
                          : selectedConvIds.has(conv.id)
                          ? "bg-primary/10 border-primary"
                          : "hover:bg-muted"
                      }`}
                    >
                      <div className="flex items-center gap-2 flex-1 min-w-0">
                        {selectMode && (
                          <input
                            type="checkbox"
                            checked={selectedConvIds.has(conv.id)}
                            onChange={() => handleToggleSelection(conv.id)}
                            onClick={(e) => e.stopPropagation()}
                            className="w-3.5 h-3.5 flex-shrink-0 rounded border-gray-300 text-primary focus:ring-primary cursor-pointer"
                          />
                        )}
                        <span className="truncate" title={conv.title}>{conv.title}</span>
                        {conv.in_knowledge_graph && (
                          <span className="text-[10px] font-semibold uppercase tracking-wide bg-emerald-100 text-emerald-700 px-2 py-0.5 rounded-full">
                            Graph
                          </span>
                        )}
                      </div>
                    </div>
                    <div className="absolute right-1 top-1 opacity-0 group-hover:opacity-100 transition-opacity">
                      <Button
                        onClick={(e) => {
                          e.stopPropagation();
                          setOpenMenuId(openMenuId === conv.id ? null : conv.id);
                        }}
                        size="sm"
                        variant="ghost"
                        className="h-7 w-7 p-0 hover:bg-transparent"
                        title="Conversation options"
                      >
                        <MoreVertical className="w-4 h-4" />
                      </Button>
                    </div>
                    {openMenuId === conv.id && (
                      <div className="absolute left-2 top-8 w-48 bg-background border rounded-lg shadow-lg z-20 py-1">
                          {!conv.in_knowledge_graph && (conv.message_count || 0) > 0 && (
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                handlePromoteConversation(conv.id);
                              }}
                              className="w-full text-left px-4 py-2 text-xs hover:bg-muted flex items-center gap-2 cursor-pointer"
                            >
                              <Database className="w-3.5 h-3.5" />
                              <span>Add to KGraph</span>
                            </button>
                          )}
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              handleArchiveConversation(conv.id);
                            }}
                            className="w-full text-left px-4 py-2 text-xs hover:bg-muted flex items-center gap-2 cursor-pointer disabled:cursor-not-allowed"
                            disabled={archivingId === conv.id || archiveLoading}
                          >
                            <Archive className="w-3.5 h-3.5" />
                            <span>
                              {archivingId === conv.id || archiveLoading
                                ? "Archiving..."
                                : "Archive"}
                            </span>
                          </button>
                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              handleDeleteConversation(conv.id);
                            }}
                            className="w-full text-left px-4 py-2 text-xs hover:bg-destructive/10 text-destructive flex items-center gap-2 cursor-pointer"
                          >
                            <Trash2 className="w-3.5 h-3.5" />
                            <span>Delete</span>
                          </button>
                        </div>
                      )}
                  </div>
                ))
              )}
            </div>
          </div>
        </AppSidebar>
      )}

      <div className={`flex-1 flex flex-col ${isWidgetMode ? "h-screen" : ""}`}>
        <ChatHeader
          isWidgetMode={isWidgetMode}
          activeId={activeId}
          sessionId={sessionId}
          experimentName={experimentName}
          loading={loading}
          onSessionChange={handleSessionChange}
          onClearSession={handleClearSession}
        />

        <div
          ref={messagesContainerRef}
          className={`flex-1 ${
            messages.length > 0 || loading || error
              ? "overflow-y-auto"
              : "overflow-hidden"
          }`}
        >
          <div className="p-6 space-y-4 max-w-4xl mx-auto">
            {loading && messages.length === 0 && (
              <div className="flex justify-center items-center py-8">
                <div className="flex items-center space-x-3 text-muted-foreground">
                  <div className="w-5 h-5 border-2 border-border border-t-primary rounded-full animate-spin"></div>
                  <span>Loading...</span>
                </div>
              </div>
            )}

            {researchProgress && (
              <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mb-4">
                <div className="flex items-center gap-3 mb-2">
                  <div className="w-5 h-5 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"></div>
                  <span className="font-medium text-blue-900 dark:text-blue-100">
                    Deep Research in Progress
                  </span>
                </div>
                <p className="text-sm text-blue-700 dark:text-blue-300 ml-8">
                  {researchProgress.currentStep}
                </p>
                <div className="ml-8 mt-2 text-xs text-blue-600 dark:text-blue-400">
                  Step {researchProgress.completedSteps} of {researchProgress.totalSteps}
                </div>
              </div>
            )}
            {!loading && messages.length === 0 && (
              <div className="flex flex-col items-center justify-center py-12 text-center">
                <div className="w-16 h-16 bg-muted rounded-full flex items-center justify-center mb-4">
                  <span className="text-2xl">üí¨</span>
                </div>
                <h3 className="text-lg font-medium text-foreground mb-2">
                  No messages yet
                </h3>
                <p className="text-muted-foreground">
                  Start the conversation by sending a message below.
                </p>
              </div>
            )}

          {/* Message List - Extracted to separate component */}
          <MessageList
            messages={messages}
            feedback={feedback}
            copiedMessageId={copiedMessageId}
            speakingMessageId={speakingMessageId}
            isSpeaking={isSpeaking}
            isPaused={isPaused}
            ttsSupported={ttsSupported}
            ttsEnabled={userSettings?.ttsEnabled || false}
            onCopyMessage={handleCopyMessage}
            onFeedback={handleFeedback}
            onToggleTTS={handleToggleTTS}
            onStopTTS={handleStopTTS}
            onEvaluate={setEvaluatingMessageId}
            onEmailResearch={handleEmailResearch}
            onDownloadResearch={handleDownloadResearch}
            isDeepResearchResult={isDeepResearchResult}
          />

          {/* Structured Research Viewer (v2 with SSE streaming) */}
          {activeResearchJob && (
            <div className="mb-6 px-4">
              <ResearchStreamViewer
                jobId={activeResearchJob.jobId}
                query={activeResearchJob.query}
              />
            </div>
          )}

          <div ref={messagesEndRef} />
          </div>
        </div>

  <div className="bg-background p-4">
          {/* Context Indicator - Right aligned, above send button */}
          {contextUsage && (
            <div className="flex justify-end max-w-4xl mx-auto w-full mb-2">
              <ContextIndicator
                usage={contextUsage}
                modelName={selectedModel?.name}
                showThreshold={90}
              />
            </div>
          )}

          <div className="max-w-[52rem] mx-auto w-full">
            <div
              className={
                "flex flex-col rounded-2xl border border-border bg-background shadow-sm " +
                (enableDeepResearch ? "gap-1 px-4 py-2.5" : "gap-2 px-3 py-2.5")
              }
            >
              {enableDeepResearch ? (
                <>
                  {/* Row 1: Input on top */}
                  <Input
                    value={input}
                    onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                      setInput(e.target.value)
                    }
                    placeholder="Type your message..."
                    onKeyDown={(e: React.KeyboardEvent<HTMLInputElement>) => {
                      if (e.key === "Enter" && !e.shiftKey) {
                        e.preventDefault();
                        handleSend();
                      }
                    }}
                    className="h-11 border-0 bg-transparent px-0 shadow-none focus-visible:ring-0 focus-visible:ring-offset-0 focus-visible:outline-none"
                  />
                  {/* Row 2: Controls below */}
                  <div className="flex items-center justify-between mt-0">
                    <div className="flex items-center gap-2">
                      {/* Deep Research Toggle Button (visible when ON) */}
                      <Button
                        onClick={() => {
                          setEnableDeepResearch(prev => {
                            const newValue = !prev;
                            log.debug('Chat', 'Deep Research toggled', { from: prev, to: newValue });
                            return newValue;
                          });
                        }}
                        variant="ghost"
                        size="sm"
                        className="h-9 px-3 shrink-0 rounded-full flex items-center gap-2 bg-blue-100 text-blue-700 hover:bg-blue-200 dark:bg-blue-900/30 dark:text-blue-400 dark:hover:bg-blue-900/50"
                        title="Disable Deep Research"
                        aria-label="Disable Deep Research"
                      >
                        <Search className="w-4 h-4" />
                        <span className="text-xs font-medium">Deep Research</span>
                      </Button>
                      {/* Plus menu for other options */}
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button
                            variant="ghost"
                            size="sm"
                            className="h-9 w-9 p-0 shrink-0 rounded-full text-gray-600 hover:text-gray-800 hover:bg-gray-100 dark:hover:bg-gray-800"
                            title="Additional options"
                            aria-label="Open additional options"
                          >
                            <Plus className="h-5 h-5" />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="start" sideOffset={8} className="w-56">
                          {/* Other menu items can go here */}
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </div>
                    <div className="flex items-center gap-2">
                      {sttSupported && userSettings?.sttEnabled && (
                        <Button
                          onClick={isListening ? stopListening : startListening}
                          variant="ghost"
                          size="sm"
                          className={`h-9 w-9 p-0 shrink-0 rounded-full text-gray-600 hover:text-gray-800 hover:bg-gray-100 dark:hover:bg-gray-800 ${
                            isListening ? "text-red-500 animate-pulse" : ""
                          }`}
                          title={isListening ? "Stop listening" : "Voice input"}
                          aria-label={isListening ? "Stop listening" : "Start voice input"}
                        >
                          {isListening ? (
                            <MicOff className="w-5 h-5" />
                          ) : (
                            <Mic className="w-5 h-5" />
                          )}
                        </Button>
                      )}
                      <Button
                        onClick={loading ? handleStop : handleSend}
                        disabled={!input.trim() && !loading}
                        variant="ghost"
                        className="h-10 w-10 p-0 shrink-0 rounded-full bg-gray-900 text-white hover:bg-gray-800 disabled:opacity-40 disabled:bg-gray-300 disabled:text-gray-500"
                        title={loading ? "Stop generating" : "Send message"}
                        aria-label={loading ? "Stop generating" : "Send message"}
                      >
                        {loading ? (
                          <StopCircle className="w-5 h-5" />
                        ) : (
                          <Send className="w-5 h-5" />
                        )}
                      </Button>
                    </div>
                  </div>
                </>
              ) : (
                <div className="flex items-center gap-2">
                  {/* Left: Deep Research Toggle Button */}
                  <Button
                    onClick={() => {
                      setEnableDeepResearch(prev => {
                        const newValue = !prev;
                        log.debug('Chat', 'Deep Research toggled', { from: prev, to: newValue });
                        return newValue;
                      });
                    }}
                    variant="ghost"
                    size="sm"
                    className={`h-9 px-3 shrink-0 rounded-full flex items-center gap-2 ${
                      enableDeepResearch 
                        ? "bg-blue-100 text-blue-700 hover:bg-blue-200 dark:bg-blue-900/30 dark:text-blue-400 dark:hover:bg-blue-900/50" 
                        : "text-gray-600 hover:text-gray-800 hover:bg-gray-100 dark:hover:bg-gray-800"
                    }`}
                    title={enableDeepResearch ? "Disable Deep Research" : "Enable Deep Research"}
                    aria-label={enableDeepResearch ? "Disable Deep Research" : "Enable Deep Research"}
                  >
                    <Search className="w-4 h-4" />
                    <span className="text-xs font-medium">Deep Research</span>
                  </Button>
                  {/* Plus menu */}
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button
                        variant="ghost"
                        size="sm"
                        className="h-9 w-9 p-0 shrink-0 rounded-full text-gray-600 hover:text-gray-800 hover:bg-gray-100 dark:hover:bg-gray-800"
                        title="Additional options"
                        aria-label="Open additional options"
                      >
                        <Plus className="h-5 w-5" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="start" sideOffset={8} className="w-56">
                      {/* Other menu items can go here */}
                    </DropdownMenuContent>
                  </DropdownMenu>
                  {/* Middle: Input expands */}
                  <Input
                    value={input}
                    onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                      setInput(e.target.value)
                    }
                    placeholder="Type your message..."
                    onKeyDown={(e: React.KeyboardEvent<HTMLInputElement>) => {
                      if (e.key === "Enter" && !e.shiftKey) {
                        e.preventDefault();
                        handleSend();
                      }
                    }}
                    className="flex-1 h-11 border-0 bg-transparent px-0 shadow-none focus-visible:ring-0 focus-visible:ring-offset-0 focus-visible:outline-none"
                  />
                  {/* Right: Voice + Send */}
                  {sttSupported && userSettings?.sttEnabled && (
                    <Button
                      onClick={isListening ? stopListening : startListening}
                      variant="ghost"
                      size="sm"
                      className={`h-9 w-9 p-0 shrink-0 rounded-full text-gray-600 hover:text-gray-800 hover:bg-gray-100 dark:hover:bg-gray-800 ${
                        isListening ? "text-red-500 animate-pulse" : ""
                      }`}
                      title={isListening ? "Stop listening" : "Voice input"}
                      aria-label={isListening ? "Stop listening" : "Start voice input"}
                    >
                      {isListening ? (
                        <MicOff className="w-5 h-5" />
                      ) : (
                        <Mic className="w-5 h-5" />
                      )}
                    </Button>
                  )}
                  <Button
                    onClick={loading ? handleStop : handleSend}
                    disabled={!input.trim() && !loading}
                    variant="ghost"
                    className="h-10 w-10 p-0 shrink-0 rounded-full bg-gray-900 text-white hover:bg-gray-800 disabled:opacity-40 disabled:bg-gray-300 disabled:text-gray-500"
                    title={loading ? "Stop generating" : "Send message"}
                    aria-label={loading ? "Stop generating" : "Send message"}
                  >
                    {loading ? (
                      <StopCircle className="w-5 h-5" />
                    ) : (
                      <Send className="w-5 h-5" />
                    )}
                  </Button>
                </div>
              )}
            </div>
          </div>
          {sttError && (
            <div className="mt-1.5 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md">
              <p className="text-sm text-red-600 dark:text-red-400">
                {sttError}
              </p>
            </div>
          )}
          {showDocumentStatus && (
            <div className="flex items-center justify-center mt-2 text-xs">
              <span className={`font-medium ${
                processedDocs.length > 0
                  ? "text-green-600 dark:text-green-500"
                  : "text-gray-500 dark:text-gray-400"
              }`}>
                {processedDocs.length > 0
                  ? `GraphRAG Ready (${processedDocs.length} ${processedDocs.length === 1 ? 'document' : 'documents'})`
                  : "GraphRAG (No documents)"
                }
              </span>
            </div>
          )}
        </div>
      </div>

      {openModal === 'export-dialog' && hasActiveConversation && !isWidgetMode && (
        <ExportDialog
          conversationIds={[activeId]}
          onClose={() => setOpenModal(null)}
          onSuccess={() => fetchConversations()}
        />
      )}

      {openModal === 'delete-confirm' && !isWidgetMode && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
          <div className="bg-background rounded-lg shadow-xl max-w-md w-full m-4 p-6">
            <h3 className="text-lg font-bold text-foreground mb-4">
              Delete {selectedConvIds.size} Conversation{selectedConvIds.size > 1 ? 's' : ''}?
            </h3>
            <p className="text-sm text-muted-foreground mb-6">
              This will permanently delete the selected conversations and all their messages. This action cannot be undone.
            </p>
            <div className="flex gap-3 justify-end">
              <Button
                onClick={() => {
                  log.debug('Chat', 'Delete confirmation cancelled');
                  setOpenModal(null);
                }}
                variant="outline"
              >
                Cancel
              </Button>
              <Button
                onClick={() => {
                  log.debug('Chat', 'Delete confirmation accepted');
                  setOpenModal(null);
                  handleBulkDelete();
                }}
                className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
              >
                Delete
              </Button>
            </div>
          </div>
        </div>
      )}

      {openModal === 'settings' && user && !isWidgetMode && session?.access_token && (
        <SettingsDialog
          isOpen={openModal === 'settings'}
          onClose={() => setOpenModal(null)}
          sessionToken={session.access_token}
          onSettingsChange={(settings) => {
            log.debug('Chat', 'Settings updated', { settings });
            setUserSettings(settings);
          }}
        />
      )}

      {openModal === 'context-inspector' && (
        <ContextInspectorPanel
          open={openModal === 'context-inspector'}
          onClose={() => setOpenModal(null)}
          usage={contextUsage}
          modelName={selectedModel?.name}
          messages={messages}
        />
      )}

      {openModal === 'model-comparison' && (
        <ModelComparisonView
          open={openModal === 'model-comparison'}
          onClose={() => setOpenModal(null)}
          sessionToken={session?.access_token}
          initialPrompt={input}
        />
      )}

      {openModal === 'archive-manager' && user && !isWidgetMode && (
        <ArchiveManager
          onClose={() => setOpenModal(null)}
          onRestore={() => fetchConversations()}
        />
      )}

      {openModal === 'knowledge-base' && user && !isWidgetMode && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
          <div className="bg-background rounded-lg shadow-xl max-w-6xl w-full max-h-[90vh] overflow-hidden flex flex-col m-4">
            <div className="flex items-center justify-between p-6 border-b">
              <h2 className="text-2xl font-bold text-foreground">
                Knowledge Base
              </h2>
              <Button
                onClick={() => setOpenModal(null)}
                variant="ghost"
                size="sm"
              >
                ‚úï
              </Button>
            </div>
            <div className="flex-1 overflow-y-auto p-6 space-y-6">
              <DocumentUpload
                userId={user.id}
                onUploadComplete={() => refetchDocuments()}
              />
              <DocumentList userId={user.id} />
            </div>
          </div>
        </div>
      )}

      {evaluatingMessageId && (
        <EvaluationModal
          messageId={evaluatingMessageId}
          onClose={() => setEvaluatingMessageId(null)}
          onSuccess={() => {
            setEvaluatingMessageId(null);
            log.debug('Chat', 'Evaluation submitted successfully');
          }}
        />
      )}
    </div>
  );
}









