/**
 * Engineering Report Template
 * Designed for senior developers and technical leads
 * Focus: Errors, latency, tool performance, debugging info
 * Date: December 15, 2025
 */

import type { ReportTemplate, RenderedReport, RenderedSection, MetricsContent, TableContent, BreakdownContent, RecommendationsContent, AlertContent } from './types';
import type { AnalyticsDataset } from '../../types';

/**
 * Engineering template definition
 * Detailed technical metrics for debugging and optimization
 */
export const engineeringTemplate: ReportTemplate = {
  id: 'engineering',
  name: 'Engineering Report',
  description: 'Detailed technical metrics for debugging and system optimization',
  targetAudience: 'Senior developers, technical leads, SRE team',
  maxPages: undefined, // No limit
  includeRawData: true,
  includeCharts: true,
  includeRecommendations: true,
  headerText: 'Engineering Performance Report',
  footerText: 'Generated by FineTuneLab Analytics',

  sections: [
    {
      id: 'eng-alerts',
      title: 'System Alerts',
      type: 'alert',
      priority: 1,
      dataSource: 'errors',
      required: true,
      formatting: {
        showTrends: false,
        showComparisons: false,
        detailLevel: 'high',
        visualStyle: 'text',
        technicalLanguage: true,
      },
    },
    {
      id: 'eng-performance',
      title: 'Performance Metrics',
      type: 'metrics',
      priority: 2,
      dataSource: 'latency',
      required: true,
      formatting: {
        showTrends: true,
        showComparisons: true,
        detailLevel: 'high',
        visualStyle: 'numbers',
        technicalLanguage: true,
      },
    },
    {
      id: 'eng-errors',
      title: 'Error Analysis',
      type: 'breakdown',
      priority: 3,
      dataSource: 'errors',
      required: true,
      formatting: {
        showTrends: true,
        showComparisons: false,
        detailLevel: 'high',
        visualStyle: 'both',
        technicalLanguage: true,
      },
    },
    {
      id: 'eng-tools',
      title: 'Tool Performance',
      type: 'table',
      priority: 4,
      dataSource: 'tools',
      required: true,
      formatting: {
        showTrends: false,
        showComparisons: false,
        detailLevel: 'high',
        visualStyle: 'both',
        maxItems: 15,
        technicalLanguage: true,
      },
    },
    {
      id: 'eng-models',
      title: 'Model Comparison',
      type: 'table',
      priority: 5,
      dataSource: 'tokenUsage',
      required: true,
      formatting: {
        showTrends: false,
        showComparisons: true,
        detailLevel: 'high',
        visualStyle: 'both',
        technicalLanguage: true,
      },
    },
    {
      id: 'eng-recommendations',
      title: 'Technical Recommendations',
      type: 'recommendations',
      priority: 6,
      dataSource: 'aggregations',
      required: true,
      formatting: {
        showTrends: false,
        showComparisons: false,
        detailLevel: 'high',
        visualStyle: 'text',
        technicalLanguage: true,
      },
    },
  ],
};

/**
 * Render engineering template with data
 */
export function renderEngineeringTemplate(data: AnalyticsDataset): RenderedReport {
  const sections: RenderedSection[] = [];

  // 1. System Alerts (critical issues first)
  const alertContent = generateAlerts(data);
  if (alertContent.level !== 'info' || alertContent.message !== 'No critical issues detected') {
    sections.push({
      id: 'eng-alerts',
      title: 'System Alerts',
      type: 'alert',
      content: alertContent,
    });
  }

  // 2. Performance Metrics
  sections.push({
    id: 'eng-performance',
    title: 'Performance Metrics',
    type: 'metrics',
    content: generatePerformanceMetrics(data),
  });

  // 3. Error Analysis
  sections.push({
    id: 'eng-errors',
    title: 'Error Analysis',
    type: 'breakdown',
    content: generateErrorBreakdown(data),
  });

  // 4. Tool Performance
  sections.push({
    id: 'eng-tools',
    title: 'Tool Performance',
    type: 'table',
    content: generateToolPerformanceTable(data),
  });

  // 5. Model Comparison
  sections.push({
    id: 'eng-models',
    title: 'Model Comparison',
    type: 'table',
    content: generateModelComparison(data),
  });

  // 6. Technical Recommendations
  sections.push({
    id: 'eng-recommendations',
    title: 'Technical Recommendations',
    type: 'recommendations',
    content: generateEngineeringRecommendations(data),
  });

  return {
    metadata: {
      templateId: 'engineering',
      templateName: 'Engineering Report',
      generatedAt: new Date().toISOString(),
      userId: data.userId,
      dateRange: {
        start: data.timeRange.start.toISOString(),
        end: data.timeRange.end.toISOString(),
      },
    },
    header: 'Engineering Performance Report',
    sections,
    footer: 'Generated by FineTuneLab Analytics',
  };
}

/**
 * Generate system alerts
 */
function generateAlerts(data: AnalyticsDataset): AlertContent {
  const { averages, totals } = data.aggregations;

  // Check for critical issues
  if (averages.errorRate > 0.15) {
    return {
      type: 'alert',
      level: 'critical',
      title: 'High Error Rate',
      message: `Error rate at ${(averages.errorRate * 100).toFixed(1)}% (${totals.errors} total errors). Immediate investigation required.`,
      timestamp: new Date().toISOString(),
    };
  }

  if (averages.successRate < 0.85) {
    return {
      type: 'alert',
      level: 'critical',
      title: 'Low Success Rate',
      message: `Success rate dropped to ${(averages.successRate * 100).toFixed(1)}%. Check recent deployments and model configurations.`,
      timestamp: new Date().toISOString(),
    };
  }

  if (averages.latencyMs > 10000) {
    return {
      type: 'alert',
      level: 'warning',
      title: 'High Latency',
      message: `Average latency at ${(averages.latencyMs / 1000).toFixed(2)}s. Consider implementing caching or optimizing prompts.`,
      timestamp: new Date().toISOString(),
    };
  }

  if (averages.errorRate > 0.05) {
    return {
      type: 'alert',
      level: 'warning',
      title: 'Elevated Error Rate',
      message: `Error rate at ${(averages.errorRate * 100).toFixed(1)}%. Review error logs for patterns.`,
      timestamp: new Date().toISOString(),
    };
  }

  return {
    type: 'alert',
    level: 'info',
    title: 'System Status',
    message: 'No critical issues detected',
    timestamp: new Date().toISOString(),
  };
}

/**
 * Generate performance metrics
 */
function generatePerformanceMetrics(data: AnalyticsDataset): MetricsContent {
  const { averages, trends } = data.aggregations;

  // Calculate P95 latency
  const latencies = data.metrics.latency.map((l) => l.latencyMs).sort((a, b) => a - b);
  const p50Index = Math.floor(latencies.length * 0.5);
  const p95Index = Math.floor(latencies.length * 0.95);
  const p99Index = Math.floor(latencies.length * 0.99);

  const p50Latency = latencies[p50Index] || 0;
  const p95Latency = latencies[p95Index] || 0;
  const p99Latency = latencies[p99Index] || 0;

  // Calculate tokens per second
  const avgTps = data.metrics.latency.length > 0
    ? data.metrics.latency.reduce((sum, l) => sum + l.tokensPerSecond, 0) / data.metrics.latency.length
    : 0;

  return {
    type: 'metrics',
    metrics: [
      {
        label: 'Avg Latency',
        value: `${(averages.latencyMs / 1000).toFixed(2)}s`,
        trend: trends.latency.direction,
        changePercent: trends.latency.changePercent,
        status: averages.latencyMs < 3000 ? 'good' : averages.latencyMs < 5000 ? 'warning' : 'critical',
      },
      {
        label: 'P50 Latency',
        value: `${(p50Latency / 1000).toFixed(2)}s`,
      },
      {
        label: 'P95 Latency',
        value: `${(p95Latency / 1000).toFixed(2)}s`,
        status: p95Latency < 5000 ? 'good' : p95Latency < 10000 ? 'warning' : 'critical',
      },
      {
        label: 'P99 Latency',
        value: `${(p99Latency / 1000).toFixed(2)}s`,
        status: p99Latency < 10000 ? 'good' : p99Latency < 15000 ? 'warning' : 'critical',
      },
      {
        label: 'Tokens/sec',
        value: avgTps.toFixed(1),
        status: avgTps > 50 ? 'good' : avgTps > 20 ? 'warning' : 'critical',
      },
      {
        label: 'Error Rate',
        value: `${(averages.errorRate * 100).toFixed(2)}%`,
        trend: trends.errorRate.direction,
        changePercent: trends.errorRate.changePercent,
        status: averages.errorRate < 0.02 ? 'good' : averages.errorRate < 0.05 ? 'warning' : 'critical',
      },
      {
        label: 'Success Rate',
        value: `${(averages.successRate * 100).toFixed(2)}%`,
        status: averages.successRate > 0.98 ? 'good' : averages.successRate > 0.95 ? 'warning' : 'critical',
      },
    ],
  };
}

/**
 * Generate error breakdown
 */
function generateErrorBreakdown(data: AnalyticsDataset): BreakdownContent {
  const errorsByType = new Map<string, number>();

  data.metrics.errors.forEach((error) => {
    const type = error.errorType || 'unknown';
    errorsByType.set(type, (errorsByType.get(type) || 0) + 1);
  });

  const totalErrors = data.metrics.errors.length;
  const items = Array.from(errorsByType.entries())
    .map(([label, value]) => ({
      label,
      value,
      percentage: totalErrors > 0 ? (value / totalErrors) * 100 : 0,
    }))
    .sort((a, b) => b.value - a.value);

  return {
    type: 'breakdown',
    title: `Error Distribution (${totalErrors} total)`,
    items,
  };
}

/**
 * Generate tool performance table
 */
function generateToolPerformanceTable(data: AnalyticsDataset): TableContent {
  const toolStats = new Map<string, { calls: number; successes: number; totalTime: number }>();

  data.metrics.tools.forEach((tool) => {
    const stats = toolStats.get(tool.toolName) || { calls: 0, successes: 0, totalTime: 0 };
    stats.calls++;
    if (tool.success) stats.successes++;
    stats.totalTime += tool.executionTimeMs;
    toolStats.set(tool.toolName, stats);
  });

  const rows = Array.from(toolStats.entries())
    .map(([name, stats]) => [
      name,
      stats.calls,
      `${((stats.successes / stats.calls) * 100).toFixed(1)}%`,
      `${(stats.totalTime / stats.calls).toFixed(0)}ms`,
      stats.calls - stats.successes,
    ])
    .sort((a, b) => (b[1] as number) - (a[1] as number))
    .slice(0, 15);

  return {
    type: 'table',
    headers: ['Tool Name', 'Calls', 'Success Rate', 'Avg Time', 'Failures'],
    rows,
    footer: `${toolStats.size} unique tools analyzed`,
  };
}

/**
 * Generate model comparison table
 */
function generateModelComparison(data: AnalyticsDataset): TableContent {
  const modelStats = new Map<string, { tokens: number; cost: number; messages: number }>();

  data.metrics.tokenUsage.forEach((usage) => {
    const stats = modelStats.get(usage.modelId) || { tokens: 0, cost: 0, messages: 0 };
    stats.tokens += usage.totalTokens;
    stats.cost += usage.estimatedCost;
    stats.messages++;
    modelStats.set(usage.modelId, stats);
  });

  const rows = Array.from(modelStats.entries())
    .map(([model, stats]) => [
      model,
      stats.messages.toLocaleString(),
      stats.tokens.toLocaleString(),
      `$${stats.cost.toFixed(2)}`,
      `$${(stats.cost / stats.messages).toFixed(4)}`,
      (stats.tokens / stats.messages).toFixed(0),
    ])
    .sort((a, b) => parseFloat((b[3] as string).replace('$', '')) - parseFloat((a[3] as string).replace('$', '')));

  return {
    type: 'table',
    headers: ['Model', 'Messages', 'Total Tokens', 'Total Cost', 'Cost/Msg', 'Tokens/Msg'],
    rows,
    footer: `${modelStats.size} models used`,
  };
}

/**
 * Generate engineering recommendations
 */
function generateEngineeringRecommendations(data: AnalyticsDataset): RecommendationsContent {
  const { averages } = data.aggregations;
  const items: RecommendationsContent['items'] = [];

  // Error analysis
  if (data.metrics.errors.length > 0) {
    const errorTypes = new Map<string, number>();
    data.metrics.errors.forEach((e) => {
      errorTypes.set(e.errorType, (errorTypes.get(e.errorType) || 0) + 1);
    });
    const topError = Array.from(errorTypes.entries()).sort((a, b) => b[1] - a[1])[0];

    if (topError && topError[1] > 5) {
      items.push({
        priority: 'high',
        title: `Investigate "${topError[0]}" Errors`,
        description: `${topError[1]} occurrences of ${topError[0]} errors detected`,
        impact: 'Resolving this error type could reduce total errors by ' +
                `${((topError[1] / data.metrics.errors.length) * 100).toFixed(0)}%`,
        actions: [
          'Review error logs for stack traces',
          'Check for recent code changes',
          'Verify API rate limits and quotas',
          'Test affected endpoints individually',
        ],
      });
    }
  }

  // Latency optimization
  if (averages.latencyMs > 3000) {
    items.push({
      priority: averages.latencyMs > 5000 ? 'high' : 'medium',
      title: 'Optimize Response Latency',
      description: `Average latency of ${(averages.latencyMs / 1000).toFixed(2)}s exceeds target`,
      impact: 'Reducing latency improves user experience and throughput',
      actions: [
        'Implement response streaming',
        'Review and optimize prompt templates',
        'Consider caching frequent queries',
        'Evaluate model selection for latency-sensitive operations',
      ],
    });
  }

  // Tool failure analysis
  const failedTools = data.metrics.tools.filter((t) => !t.success);
  if (failedTools.length > 0) {
    const failureRate = failedTools.length / data.metrics.tools.length;
    if (failureRate > 0.05) {
      items.push({
        priority: 'medium',
        title: 'Improve Tool Reliability',
        description: `Tool failure rate at ${(failureRate * 100).toFixed(1)}%`,
        impact: 'Reliable tools reduce fallbacks and improve response quality',
        actions: [
          'Add timeout handling to tool implementations',
          'Implement retry logic with exponential backoff',
          'Add better error messages for debugging',
          'Consider circuit breaker patterns for external APIs',
        ],
      });
    }
  }

  // Cost optimization
  if (averages.costPerMessage > 0.02) {
    items.push({
      priority: 'medium',
      title: 'Reduce Token Usage',
      description: `Cost per message ($${averages.costPerMessage.toFixed(4)}) is above threshold`,
      impact: 'Token optimization can reduce costs by 30-50%',
      actions: [
        'Audit prompts for unnecessary verbosity',
        'Implement prompt compression techniques',
        'Use smaller models for simpler tasks',
        'Cache common responses where appropriate',
      ],
    });
  }

  // Add general recommendation if no issues
  if (items.length === 0) {
    items.push({
      priority: 'low',
      title: 'System Health Good',
      description: 'All metrics within acceptable ranges',
      impact: 'Continue monitoring for anomalies',
      actions: [
        'Set up alerting for metric thresholds',
        'Document current baseline for comparison',
        'Review weekly for trend changes',
      ],
    });
  }

  return {
    type: 'recommendations',
    items,
  };
}
