/**
 * Worker Heartbeat API
 * POST /api/workers/{workerId}/heartbeat - Worker heartbeat with status update
 * Date: 2025-12-26
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { authenticateWorkerApiKey } from '@/lib/auth/worker-auth';

export const runtime = 'nodejs';

interface HeartbeatRequest {
  status?: 'online' | 'error';
  current_load?: number;
  metrics?: {
    cpu_percent?: number;
    memory_used_mb?: number;
    memory_total_mb?: number;
    disk_used_gb?: number;
    disk_total_gb?: number;
    network_sent_mbps?: number;
    network_recv_mbps?: number;
    trading_status?: string;
    active_trades?: number;
  };
  metadata?: Record<string, unknown>;
}

interface HeartbeatResponse {
  ok: boolean;
  pending_commands: Array<{
    id: string;
    command_type: string;
    params: Record<string, unknown>;
    signature: string;
    timeout_seconds: number;
    created_at: string;
  }>;
}

export async function POST(
  request: NextRequest,
  { params }: { params: { workerId: string } }
) {
  try {
    const { workerId } = params;

    // Authenticate worker using API key
    const auth = await authenticateWorkerApiKey(request);
    if (!auth.ok) {
      return NextResponse.json({ error: auth.error }, { status: auth.status });
    }

    // Verify worker_id matches authenticated worker
    if (auth.workerId !== workerId) {
      return NextResponse.json(
        { error: 'Worker ID mismatch' },
        { status: 403 }
      );
    }

    // Parse request body
    const body: HeartbeatRequest = await request.json().catch(() => ({}));

    // Get Supabase client with service role
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

    if (!supabaseUrl || !supabaseServiceKey) {
      console.error('[Worker Heartbeat] Missing Supabase environment variables');
      return NextResponse.json(
        { error: 'Server configuration error' },
        { status: 500 }
      );
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // Update worker heartbeat and status
    const updateData: Record<string, unknown> = {
      last_heartbeat: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };

    if (body.status) {
      updateData.status = body.status;
    } else {
      updateData.status = 'online'; // Default to online if heartbeat received
    }

    if (body.current_load !== undefined) {
      updateData.current_load = body.current_load;
    }

    if (body.metadata) {
      // Merge with existing metadata
      const { data: existingWorker } = await supabase
        .from('worker_agents')
        .select('metadata')
        .eq('worker_id', workerId)
        .single();

      if (existingWorker) {
        updateData.metadata = {
          ...(existingWorker.metadata || {}),
          ...body.metadata,
        };
      } else {
        updateData.metadata = body.metadata;
      }
    }

    const { error: updateError } = await supabase
      .from('worker_agents')
      .update(updateData)
      .eq('worker_id', workerId);

    if (updateError) {
      console.error('[Worker Heartbeat] Failed to update worker:', updateError);
      return NextResponse.json(
        { error: 'Failed to update heartbeat' },
        { status: 500 }
      );
    }

    // Insert metrics if provided
    if (body.metrics) {
      const { error: metricsError } = await supabase
        .from('worker_metrics')
        .insert({
          worker_id: workerId,
          user_id: auth.userId,
          timestamp: new Date().toISOString(),
          cpu_percent: body.metrics.cpu_percent,
          memory_used_mb: body.metrics.memory_used_mb,
          memory_total_mb: body.metrics.memory_total_mb,
          disk_used_gb: body.metrics.disk_used_gb,
          disk_total_gb: body.metrics.disk_total_gb,
          network_sent_mbps: body.metrics.network_sent_mbps,
          network_recv_mbps: body.metrics.network_recv_mbps,
          trading_status: body.metrics.trading_status,
          active_trades: body.metrics.active_trades,
        });

      if (metricsError) {
        console.warn('[Worker Heartbeat] Failed to insert metrics:', metricsError);
        // Don't fail the heartbeat if metrics insertion fails
      }
    }

    // Fetch pending commands for this worker
    const { data: pendingCommands, error: commandsError } = await supabase
      .from('worker_commands')
      .select('id, command_type, params, signature, timeout_seconds, created_at')
      .eq('worker_id', workerId)
      .eq('status', 'pending')
      .order('created_at', { ascending: true })
      .limit(10);

    if (commandsError) {
      console.error('[Worker Heartbeat] Failed to fetch commands:', commandsError);
      // Don't fail heartbeat if command fetch fails
    }

    // Mark fetched commands as 'executing'
    if (pendingCommands && pendingCommands.length > 0) {
      const commandIds = pendingCommands.map((cmd) => cmd.id);
      await supabase
        .from('worker_commands')
        .update({
          status: 'executing',
          started_at: new Date().toISOString(),
        })
        .in('id', commandIds);
    }

    const response: HeartbeatResponse = {
      ok: true,
      pending_commands: (pendingCommands || []).map((cmd) => ({
        id: cmd.id,
        command_type: cmd.command_type,
        params: cmd.params as Record<string, unknown>,
        signature: cmd.signature,
        timeout_seconds: cmd.timeout_seconds,
        created_at: cmd.created_at,
      })),
    };

    return NextResponse.json(response);
  } catch (err) {
    console.error('[Worker Heartbeat] Unexpected error:', err);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}