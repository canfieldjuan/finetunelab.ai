/**
 * Worker Metrics Ingestion API
 * POST /api/workers/{workerId}/metrics - Batch metrics ingestion
 * Date: 2025-12-25
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { authenticateWorkerApiKey } from '@/lib/auth/worker-auth';

export const runtime = 'nodejs';

interface MetricsSnapshot {
  timestamp: number; // Unix timestamp in milliseconds
  snapshot: {
    cpu_percent?: number;
    memory_used_mb?: number;
    memory_total_mb?: number;
    disk_used_gb?: number;
    disk_total_gb?: number;
    network_sent_mbps?: number;
    network_recv_mbps?: number;
    trading_status?: string;
    active_trades?: number;
  };
}

interface MetricsBatchRequest {
  batch: MetricsSnapshot[];
}

/**
 * POST /api/workers/{workerId}/metrics
 *
 * Batch metrics ingestion for worker agents.
 * Allows workers to send multiple metrics snapshots at once.
 *
 * Request Body:
 * {
 *   batch: [
 *     {
 *       timestamp: 1735145600000,
 *       snapshot: {
 *         cpu_percent: 45.2,
 *         memory_used_mb: 2048,
 *         memory_total_mb: 16384,
 *         disk_used_gb: 120,
 *         disk_total_gb: 512,
 *         network_sent_mbps: 1.5,
 *         network_recv_mbps: 3.2,
 *         trading_status: "running",
 *         active_trades: 5
 *       }
 *     }
 *   ]
 * }
 *
 * Response:
 * {
 *   ingested_count: 1
 * }
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { workerId: string } }
) {
  try {
    const { workerId } = params;

    // Authenticate worker using API key
    const auth = await authenticateWorkerApiKey(request);
    if (!auth.ok) {
      return NextResponse.json({ error: auth.error }, { status: auth.status });
    }

    // Verify worker_id matches authenticated worker
    if (auth.workerId !== workerId) {
      return NextResponse.json(
        { error: 'Worker ID mismatch' },
        { status: 403 }
      );
    }

    // Parse request body
    const body: MetricsBatchRequest = await request.json();

    // Validate batch
    if (!body.batch || !Array.isArray(body.batch)) {
      return NextResponse.json(
        { error: 'Missing or invalid batch field. Expected array of metrics.' },
        { status: 400 }
      );
    }

    if (body.batch.length === 0) {
      return NextResponse.json(
        { error: 'Empty batch. At least one metric snapshot required.' },
        { status: 400 }
      );
    }

    // Limit batch size to prevent abuse
    const MAX_BATCH_SIZE = 100;
    if (body.batch.length > MAX_BATCH_SIZE) {
      return NextResponse.json(
        {
          error: `Batch too large. Maximum ${MAX_BATCH_SIZE} metrics per request.`,
          provided: body.batch.length,
        },
        { status: 400 }
      );
    }

    // Get Supabase client with service role
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

    if (!supabaseUrl || !supabaseServiceKey) {
      console.error('[Worker Metrics] Missing Supabase environment variables');
      return NextResponse.json(
        { error: 'Server configuration error' },
        { status: 500 }
      );
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // Transform batch into database records
    const metricsRecords = body.batch.map((metric) => ({
      worker_id: workerId,
      user_id: auth.userId,
      timestamp: new Date(metric.timestamp).toISOString(),
      cpu_percent: metric.snapshot.cpu_percent,
      memory_used_mb: metric.snapshot.memory_used_mb,
      memory_total_mb: metric.snapshot.memory_total_mb,
      disk_used_gb: metric.snapshot.disk_used_gb,
      disk_total_gb: metric.snapshot.disk_total_gb,
      network_sent_mbps: metric.snapshot.network_sent_mbps,
      network_recv_mbps: metric.snapshot.network_recv_mbps,
      trading_status: metric.snapshot.trading_status,
      active_trades: metric.snapshot.active_trades,
    }));

    // Batch insert metrics
    const { data, error: insertError } = await supabase
      .from('worker_metrics')
      .insert(metricsRecords)
      .select('id');

    if (insertError) {
      console.error('[Worker Metrics] Failed to insert metrics:', insertError);
      return NextResponse.json(
        {
          error: 'Failed to insert metrics',
          details: insertError.message,
        },
        { status: 500 }
      );
    }

    console.log('[Worker Metrics] Ingested metrics batch:', {
      worker_id: workerId,
      count: data?.length || 0,
    });

    return NextResponse.json({
      ingested_count: data?.length || 0,
    });

  } catch (err) {
    console.error('[Worker Metrics] Unexpected error:', err);
    return NextResponse.json(
      {
        error: 'Internal server error',
        details: err instanceof Error ? err.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}